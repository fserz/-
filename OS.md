#  OS学习笔记

## 计算机系统概述

操作系统是计算机系统中最基本的**系统软件**。

### OS特征  

**并发**和**共享**是最基础的，互为条件。

1. **并发**  宏观上同时发生，微观上交替发生。

并发：两个或多个事件在**同一时间间隔**内发生。

并行：**同一时刻**

2. **共享**

3. **虚拟**

4. **异步**

### OS发展与分类

1. **手工阶段**  **人机速度矛盾**
2. **批处理阶段**  

（1）单道批  **只能串行** 优：缓解人机速度矛盾 缺：资源利用率低

（2）多道批  **并行**  优：多道程序并发执行，资源利用率高 缺：无人机交互功能

3. **分时操作系统**

**分时技术**：把处理机的运行时间分成很短的时间片，按时间片把各处理机分给各联机作业使用。

优：提供人机交互

缺：不能优先处理紧急任务

4. **实时操作系统**

优：能及时处理紧急任务

### OS运行机制

CPU状态分为**用户态（目态）**和**核心态（管态、内核态）**

用户自编程有运行在**用户态**，操作系统内核程序运行在**核心态**

#### 中断和异常

**中断**也称外中断，信号来源：CPU **外部**，与当前执行的指令**无关**。

**异常**也称内中断，信号来源：CPU**内部**，与当前执行指令**有关**。

用户态→核心态 **中断**是**唯一**途径。

核心态→用户态  只需通过**执行一个特权指令**，将程序状态字（PSW）的状态设置为“用户态”。

中断过程：

1. 关中断
2. 保存断点
3. 中断服务程序寻址
4. 保存现场和屏蔽字
5. 开中断
6. 执行中断服务程序
7. 关中断
8. 恢复现场和屏蔽字
9. 开中断、中断返回

传递系统参数→执行陷入命令**（用户态）**→ 执行系统调用相应服务程序**（核心态）**→ 返回用户程序

1. **陷入指令**在**用户态**执行的，执行陷入指令之后，立即引发一个**内中断**，从而CPU进入**核心态**。
2. **发出系统调用请求**是在**用户态**，而**对系统调用的相应处理**是在**核心态**。
3. 陷入指令是**唯一一个**只能在**用户态**执行，而不可在核心态执行的指令。

## 进程管理

### 进程

PCB（进程控制块）是进程存在的唯一标志。

**运行态**  CPU√   其他√

**就绪态**  CPU×   其他√  就绪态**仅缺少处理机**。

**阻塞态**  CPU×   其他× 阻塞态是指进程需要除了处理机的其他资源，或等待某一事件。

运行态→阻塞态 是**主动**行为，阻塞态→就绪态是**被动**行为。

### 线程

引入**进程**的目的是更好地使多道程序并发执行，提高资源利用率和系统吞吐量。引入**线程**的目的是减小程序在并发执行时所付出的时空开销，提高系统的并发性能。

**进程**是资源分配的基本单位，**线程**是处理机调度的基本单位。

### 处理机调度

1. **作业调度**  内存与辅存之间的调度    **一次**
2. **中级调度**  将暂时不运行的进程调至外存    **几分钟**
3. **低级调度**  从就绪序列选取一个进程，将处理机分给他   **几十毫秒**

吞吐率 = 总共完成多少作业/总共时间

周转时间 = 作业完成时间 - 作业提交时间

带权周转时间 = 作业周转时间 / 作业实际运行时间 

平均带权周转时间 = （作业1带权周转时间+作业2带权周转时间+...作业n带权周转时间+）/n

#### 调度算法

1. FCFS（先来先服务）**只考虑等待时间**
2. SJF（短作业优先）**只考虑运行时间**    会导致长作业长时间不被调度，出现**饥饿**
3. 优先级调度算法  会**饥饿**
4. 高响应比优先调度算法 **综合考虑等待时间和运行时间**  不会饥饿

响应比 = （等待时间 + 要求服务时间）/ 要求服务时间

5. 时间片轮转调度  不会饥饿
6. 多级反馈队列调度算法

死锁 ——系统环形等待，饥饿——调度策略问题

### 进程同步

**临界资源**：一次允许一个进程使用的资源。

同步机制应遵循以下准则：

1. 空则让进
2. 忙则等待
3. 有限等待
4. 让权等待

#### 信号量实现同步互斥

**P操作**，wait操作，**请求**一个资源

**V操作**，signal操作，**释放**一个资源

1. 信号量实现**同步**：

s = **0**，**前V后P**（前操作之后V，后操作前P）

2. 信号量实现**互斥**：

s = **1**，PV操作夹住临界区代码

### 同步问题

1. **生产者与消费者**

**特征：容器 ≤ 容量**

生产者—剩余空间—empty

消费者—已占空间—full

2. **读者写者问题**

特征：（1）只关心资源是否被占用 （2）写者→资源—读者  只有写者有→

写者—资源是否被占用

读者（团）—（1）第一个读者-文件是否被占用

​                       （2）中间读者：增加读者团人数

​                       （3）最后一个：释放文件

**解题流程：**

1. **画图理解题目**
2. **判断题目类型**
3. **分析进程数目填写进程模板**
4. **补充基本代码**

```
i(){

while(1){

  }
}
```

读写与消费生产**区别**：

1. 对资源的影响
2. 读者—读者是一个**团体**

### 死锁

**死锁**：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进。

**饥饿**：由于长期得不到资源，某进程无法推进的现象。

**死循环**：某个进程执行过程中一直跳不出某个循环。

死锁产生的**四个必要条件**：

1. **互斥条件**
2. **不可剥夺**
3. **请求并保持**
4. **循环等待**

一个不成立就，不会死锁。

循环等待**未必**死锁，死锁**一定**循环等待。

####　死锁处理

1. 死锁处理

破坏4个必要条件中的一个或几个

2. 避免死锁

防止系统进入不安全状态（银行家算法 NEED = MAX - ALLOCATION再用AVALIBLE和NEED比较）

3. 死锁的检测及解除

圆圈代表一个进程，框代表一类资源。进程到资源为**请求边**，资源到进程为分配边。

化简过程：寻找圆圈进程，**判断申请边，是否能满足**，满足则删除其所有边。不能消除所有边则出现死锁。

## 内存管理

**相对**地址又称**逻辑**地址。

**绝对**地址又称**物理**地址。

内存管理功能：

1. 内存管理的分配与回收
2. 地址转换
3. 内存空间的扩充
4. 存储保护

#### 覆盖和交换

覆盖和交换是在多道程序环境下用来**扩充内存**的两种方法。

**覆盖**：由于程序运行时并非任何时候都要访问程序及访问程序及数据的各个部分(尤其是最大程序)，因此可以把用户空间分成一个固定区和若干覆盖区。将经常活跃的部分放在固定区，其余部分按调用关系分段。首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统再将其调入覆盖区，替换覆盖区中原有的段。

**交换**：把处于等待状态（或在CPU调度原则下被剥夺运行权利）的程序从内存移到辅存，把内存空间腾出来，这一过程称为**换出**，把准备好竞争CPU运行的程序从赋存移到内存，这一过程称为**换入**。

#### 连续分配方式

1. 单一连续分配 **无外部碎片，有内部碎片**
2. 固定分区分配 **无外部，有内部**
3. 动态分区分配 **无内部，有外部**

​            考虑一下算法：（1）首次适应算法  分区以**地址递增**链接

​                                       （2）最佳适应算法  **容量递增**

​                                       （3）最坏适应算法  **容量递减**

​                                       （2）邻近适应算法  由首次适应算法演变来，从上次**查找结束的位置**继续开始查找

**固定分区**产生**内部碎片**，**动态分区**产生**外部碎片**。

#### 非连续分配管理方式

##### **分页存储管理**

**分页**：把主存空间划分为大小相等且固定的块，块相对较小，作为贮存的基本单位。

进程中的块称为**页**，内存中的块称为**页框**或**页帧**。外存以同样的单位进行划分，直接称为**块**。

页表项 = 页号 + 物理内存中块号

地址结构 = 页号 + 页内偏移

物理地址 = 页面始址 + 页内偏移量

页号 = 逻辑地址 / 页面长度

页内偏移量 = 逻辑地址 % 页面长度

**地址结构：页号P+页内偏移量W**

地址转换：

1. 根据逻辑地址计算页号
2. 判断页号是否越界
3. 查询页表，找到页号，对应页表项，确定页面存放的内存块号
4. 用内存块号和页内偏移量得到物理地址
5. 访问目标内存单元

页表长度 ：页表中总共有几个页表项，即共有多少页

页表项长度：每个页表项占多大的存储空间

页面大小：一个页面占多大的存储空间

##### **分段存储管理**

**分段**：段式管理按照用户进程中的自然段划分逻辑空间。

**段内**要求**连续**，**段间不**要求**连续**。   

**段的位数**决定了每个进程**最多可以分多少块**。

**段内地址**决定了**每个段的最大长度**是多少。

**地址结构：段号S + 段内偏移量W**

地址变换：

1. 根据逻辑地址得到段号，段内地址
2. 判断段号是否越界。若S>=M则产生越界中断，否则继续执行。（段表长度至少是1，而段号从0开始）
3. 查询段表，找到对应的段表项，段表项存放地址=段表始址 F +段号 S * 段表项长度
4. 检查段内地址是否超过段长（和分页不同，不同的分段段长不相同），若W>=C,则产生越界中断，否则继续执行。

##### 段页式管理方式

**地址结构：段号S+页号P+页内偏移量W**

**段号**决定了每个进程可以分几段。

**页号位数**决定了每个段最多有多少页。

**页内偏移量**决定了页面大小、内存块大小是多少。

在一个进程中，**段表**只有**一个**，而**页表**可能有**多个**。

地址变换：

1. 根据逻辑地址得到段号、页号、页内偏移量。
2. 判断段号是否越界，若S>=M,则产生越界中断，否则继续执行。
3. 查询段表，找到对应的段表项，段表项的存储地址为F＋Ｓ＊段表项长度
4. 检查页号是否越界，若页号 >= 页表长度，则发生越界中断，否则继续执行。
5. 根据逻辑地址得到段号，页号，页内偏移量。
6. 根据内存块号得到最终的物理地址。
7. 访问目标内存单元。

#### 虚拟内存管理

**局部性原理**

1. **时间局部性**  程序中的某条指令一旦执行，不久后可能再次执行。某数据被访问过，不久后可能再次访问。
2. **空间局部性**  一旦访问了某个存储单元，不久后，其附近的存储单元也将被访问。

虚拟内存**最大容量**由计算机地址结构确定（**CPU寻址范围**）

​                **实际容量 = min（内存外存之和， CPU寻址范围）**

##### 页面置换算法

1. 最佳（OPT）置换算法  **向后看**，无法实现

2. 先进先出（FIFO ）只有FIFO会出现**Belady现象**（分配的物理块数增大，而页故障数不减反增）

3. 最近最久未使用（LRU）置换算法  **向前看**

4. 时钟（CLOCK）置换算法

   ​       （1）简单的CLOCK算法 又称最近未用（LRU） **最多2轮**  访问位为零淘汰，为1置0

   ​       （2）改进型CLOCK置换算法  **最多4轮**  （访问位，修改位）

   ​                      第一轮淘汰（0,0）  第二轮淘汰（0,1），并将扫过的访问位置为0    第三轮淘汰（0,0）第四轮淘汰（0,1）

##### 页面分配策略

1. 固定分配局部置换
2. 可变分配全局置换
3. 可变分配局部置换

**全局置换**则一个进程拥有的物理快数量必然会改变，因此**不可能是固定分配**。

对换区：读写速度快，连续分配方式

文件区：读写速度慢，离散分配方式

**抖动（颠簸）**：刚换出的页面马上又要换入主存，刚刚换入的页面马上又要换出主存。   主要原因：某个进程频繁访问的页面数目高于可用的物理页帧数目。

## 文件管理

系统运行中，计算机以**进程**为基本单位进行资源的调度和分配；而在用户进行的输入、输出中，则以**文件**为基本单位。

文件的**逻辑结构**是从用户的观点出发看到的文件组织形式。文件的**物理结构**是从实现的观点出发看到的文件在外存上的存储组织形式。

按逻辑结构分为：无结构文件和有结构文件

1. 无结构文件（流式文件）

2. 有结构文件（记录式文件）  

​              (1）顺序文件

​           （2）索引文件

​           （3）索引顺序文件（索引+顺序）

​           （4）直接文件或散列文件

### 文件共享

文件共享使多个用户（进程）共享同一个文件，系统只需保留文件的一个副本。

两种文件共享方法：

1. 基于索引节点的共享方式（**硬链接**）
2. 利用符号链实现文件共享（**软链接**）

**硬链接**就是多个指针指向一个索引结点。保证只要还有一个指针指向索引结点，索引结点就不能删除；**软链接**就是把到达共享文件的记录下来，当要访问文件时，根据路径寻找文件。硬链接速度比软链接快。

**硬链接**和**软链接**都是文件系统中的**静态共享**方法，在文件系统中还存在着另外的共享需求，即两个进程同时对同一个文件进行操作，这样的共享称为**动态共享**。

### 文件分配方式

1. 连续分配 

   优：读写速度最快 缺：文件不方便扩展，空间利用率低。  支持顺序访问和随机访问。

2. 链接分配 

   优：方便扩展，空间利用率高，不会有碎片问题。缺：只支持顺序访问。

3. 索引分配

   一个文件对应一张索引表。支持随机访问。文件扩展容易实现。

**访问第n条记录**，**连续分配**访问磁盘**1次**，**链接分配**访问**n次**，**索引分配m级**需访问磁盘**m+1次**

### 磁盘组织管理

**（柱面号，盘面号，扇区号）**

每个盘面对应一个磁头，所有磁头连在同一个磁臂上，所有磁头只能共进退。

**一次磁盘操作时间 = 寻道时间 + 旋转延迟时间 + 传输时间**

**寻道时间**：启动磁臂时间s，m是与磁盘驱动器相关的常数 Ts = **m*n +ｓ**

**旋转延迟时间**：旋转速度ｒ　　**1/2r**   (1/r转一圈，平均半圈)

**传输时间**：每次所读字节数b，N为一个磁道上的字节数     **b/rN**

**总平均存取时间 = Ts + 1/2r + b/rN**

**寻道时间**是将磁头移动到指定磁道所需要的时间；**延迟时间**是磁头定位到某一磁道的扇区（块号）所需要的时间；**传输时间**是从磁盘读出或向磁盘写入数据所经历的时间。    

### 磁盘调度算法

调度算法决定寻道时间

1. 先来先服务（FCFS）算法
2. 最短寻找时间（SSTF） 会**饥饿**
3. 扫描SCAN算法（电梯调度算法）磁头移动到最外侧才能向内移动，移动到最内侧才能向外移动。
4. 循环扫描C-SCAN算法  磁头移动到最外侧才能向内移动，快速**移动至另一端起始端**。
5. LOOK调度    在电梯调度的基础上，磁头移动到只需要到达最远端的一个请求即可返回，不需要到达磁盘终点。
6. C-LOOK调度    在循环扫描的基础上，磁头移动到只需要到达最远端的一个请求即可返回，不需要到达磁盘终点。

对盘面扇区进行**交替编号**，对磁盘片组中的不同盘面**错位命名**。

## I/O管理

### I/O控制方式

1. **程序直接控制方式**

CPU大部分时间都处于等待I/O设备完成数据I/O的循环测试中。CPU和I/O**只能串行**工作，CPU利用率非常低。

2. **中断驱动方式**

允许I/O设备主动打断CPU，从而**“解放”CPU**，使得其向I/O控制器发送读命令后可以继续做其他有用的工作。

3. **DMA方式**

I/O设备和内存之间开辟新的数据交换通路，**彻底“解放”CPU**。

**中断和DMA区别**：

中断驱动在**每个数据**传输时中断CPU，而DMA控制方式则是在所要求传送的**一批数据全部传送结束时**才中断CPU；中断驱动方式数据传送是在中断处理时由**CPU**完成，而DMA则是在**DMA控制器**下完成。

4. **通道控制方式**

I/O通道是专门负责输入/输出的处理机，进一步减少CPU的干预。

**通道**：一种**硬件**，可以认为是弱鸡版的CPU，可以识别并执行一系列通道指令。

**I/O通道与一般处理机的区别**：

通道**指令单一**，没有自己的内存，通道与CPU**共享内存**。

**I/O通道与DMA区别**：

DMA方式需要CPU来控制传输的**数据快大小、传输的内存位置**，而通道方式中这些信息是由通道控制的。另外，每个DMA控制器对应**一台设备**与内存传递数据，而一个通道可以控制**多台设备**与内存的数据交换。

### I/O核心子系统

#### I/O调度

确定一个好的顺序来执行这些I/O操作

#### 高速缓存与缓冲区

1. 磁盘高速缓存（Disk Cache）

磁盘高速缓存逻辑上属于磁盘，物理上则是驻留在内存中的盘块。两种形式（1）内存中开辟一个单独的存储空间作为磁盘高速缓存，大小固定（2）一种是把未利用的内存空间作为一个缓冲池，供请求分页系统和磁盘I/O时共享。

2. 缓冲区（为空才能注入数据）

当缓冲区的**数据非空**时，**不能**往缓冲区**冲入数据**，**只能**从缓冲区把**数据传出**；当缓冲区**为空**时，可以往缓冲区**充满后**，才能从缓冲区把**数据传出**。

​      （1）**单缓冲** 

​          数据传入缓冲区的时间为T，缓冲区的数据传到用户的时间为M，CPU处理一个数据的时间为C

​           单缓冲区处理一块数据的时间为 **max(C,T) + M**

​       （2）**双缓冲**

​          单缓冲区处理一块数据的时间为**max(C+M,T)**

####　SPOOLING技术（假脱机技术）

为了**缓和CPU的高速性与I/O设备低速性**之间的矛盾，引入了**脱机输入/输出技术**。

1. **输入井和输出井**

输入井和输出井是指在**磁盘**上开辟出的两个存储区域。输入井模拟脱机输入时的磁盘，用于收容I/O设备输入的数据。输出井模拟脱机输出时的磁盘，用于收容用户程序的输出数据。

2. **输入缓冲区和输出缓冲区**

输入缓冲区和输出缓冲区是**内存**中开辟的两个存储区中开辟了两个缓冲区。输入缓冲区用于暂存由输入设备送来的数据，以后再传送到输入井，输出缓冲区用于暂存从输入井送来的数据，以后再传送到输出设备。

3. **输入数据和输出数据**

 SPOOLING系统的主要特点：提高了I/O的速度：将独占设备改造为共享设备：实现了虚拟设备功能。

SPOOLING是一种以**空间换时间**的技术。

**设备独立性**是指用户在编程序时使用的设备与实际设备无关。
